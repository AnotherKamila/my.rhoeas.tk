var DynamicMode, LAST_QUEUED_STICKER, Plugin, future_size, history_size, mpd,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = Object.prototype.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

Plugin = require('../plugin').Plugin;

mpd = require('../mpd');

history_size = parseInt(process.env.npm_package_config_dynamicmode_history_size);

future_size = parseInt(process.env.npm_package_config_dynamicmode_future_size);

LAST_QUEUED_STICKER = "groovebasin.last-queued";

exports.Plugin = DynamicMode = (function(_super) {

  __extends(DynamicMode, _super);

  function DynamicMode() {
    this.getRandomSongFiles = __bind(this.getRandomSongFiles, this);
    this.updateStickers = __bind(this.updateStickers, this);
    this.checkDynamicMode = __bind(this.checkDynamicMode, this);
    this.onSocketConnection = __bind(this.onSocketConnection, this);
    this.setMpd = __bind(this.setMpd, this);
    this.setConf = __bind(this.setConf, this);
    this.saveState = __bind(this.saveState, this);
    this.restoreState = __bind(this.restoreState, this);    DynamicMode.__super__.constructor.apply(this, arguments);
    this.previous_ids = {};
    this.is_enabled = false;
    this.got_stickers = false;
  }

  DynamicMode.prototype.restoreState = function(state) {
    var _ref, _ref2;
    this.is_on = (_ref = state.status.dynamic_mode) != null ? _ref : false;
    return this.random_ids = (_ref2 = state.status.random_ids) != null ? _ref2 : {};
  };

  DynamicMode.prototype.saveState = function(state) {
    state.status.dynamic_mode = this.is_on;
    state.status.dynamic_mode_enabled = this.is_enabled;
    return state.status.random_ids = this.random_ids;
  };

  DynamicMode.prototype.setConf = function(conf, conf_path) {
    this.is_enabled = true;
    if (conf.sticker_file == null) {
      this.is_enabled = false;
      this.is_on = false;
      return this.log.warn("sticker_file not set in " + conf_path + ". Dynamic Mode disabled.");
    }
  };

  DynamicMode.prototype.setMpd = function(mpd) {
    this.mpd = mpd;
    this.mpd.on('statusupdate', this.checkDynamicMode);
    this.mpd.on('playlistupdate', this.checkDynamicMode);
    return this.mpd.on('libraryupdate', this.updateStickers);
  };

  DynamicMode.prototype.onSocketConnection = function(socket) {
    var _this = this;
    return socket.on('DynamicMode', function(data) {
      var args, did_anything, key, value;
      if (!_this.is_enabled) return;
      args = JSON.parse(data.toString());
      _this.log.debug("DynamicMode args:");
      _this.log.debug(args);
      did_anything = false;
      for (key in args) {
        value = args[key];
        switch (key) {
          case "dynamic_mode":
            if (_this.is_on === value) continue;
            did_anything = true;
            _this.is_on = value;
        }
      }
      if (did_anything) {
        _this.checkDynamicMode();
        return _this.onStatusChanged();
      }
    });
  };

  DynamicMode.prototype.checkDynamicMode = function() {
    var add_count, all_ids, commands, current_id, current_index, delete_count, file, i, id, item, item_list, new_files, new_random_ids, _i, _len, _len2, _ref,
      _this = this;
    if (!this.is_enabled) return;
    if (!this.mpd.library.artists.length) return;
    if (!this.got_stickers) return;
    item_list = this.mpd.playlist.item_list;
    current_id = (_ref = this.mpd.status.current_item) != null ? _ref.id : void 0;
    current_index = -1;
    all_ids = {};
    new_files = [];
    for (i = 0, _len = item_list.length; i < _len; i++) {
      item = item_list[i];
      if (item.id === current_id) current_index = i;
      all_ids[item.id] = true;
      if (this.previous_ids[item.id] == null) new_files.push(item.track.file);
    }
    this.mpd.sendCommands((function() {
      var _i, _len2, _results;
      _results = [];
      for (_i = 0, _len2 = new_files.length; _i < _len2; _i++) {
        file = new_files[_i];
        _results.push("sticker set song \"" + file + "\" \"" + LAST_QUEUED_STICKER + "\" " + (JSON.stringify(new Date())));
      }
      return _results;
    })());
    for (_i = 0, _len2 = new_files.length; _i < _len2; _i++) {
      file = new_files[_i];
      this.mpd.library.track_table[file].last_queued = new Date();
    }
    if (current_index === -1) {
      current_index = 0;
    } else {
      for (i = 0; 0 <= current_index ? i <= current_index : i >= current_index; 0 <= current_index ? i++ : i--) {
        delete this.random_ids[item_list[i].id];
      }
    }
    if (this.is_on) {
      commands = [];
      delete_count = Math.max(current_index - history_size, 0);
      if (history_size < 0) delete_count = 0;
      for (i = 0; 0 <= delete_count ? i < delete_count : i > delete_count; 0 <= delete_count ? i++ : i--) {
        commands.push("deleteid " + item_list[i].id);
      }
      add_count = Math.max(future_size + 1 - (item_list.length - current_index), 0);
      commands = commands.concat((function() {
        var _j, _len3, _ref2, _results;
        _ref2 = this.getRandomSongFiles(add_count);
        _results = [];
        for (_j = 0, _len3 = _ref2.length; _j < _len3; _j++) {
          file = _ref2[_j];
          _results.push("addid " + (JSON.stringify(file)));
        }
        return _results;
      }).call(this));
      this.mpd.sendCommands(commands, function(msg) {
        var changed, line, name, value, _j, _len3, _ref2, _ref3;
        changed = false;
        _ref2 = msg.split("\n");
        for (_j = 0, _len3 = _ref2.length; _j < _len3; _j++) {
          line = _ref2[_j];
          _ref3 = line.split(": "), name = _ref3[0], value = _ref3[1];
          if (name !== "Id") continue;
          _this.random_ids[value] = 1;
          changed = true;
        }
        if (changed) return _this.onStatusChanged();
      });
    }
    new_random_ids = {};
    for (id in this.random_ids) {
      if (all_ids[id]) new_random_ids[id] = 1;
    }
    this.random_ids = new_random_ids;
    this.previous_ids = all_ids;
    return this.onStatusChanged();
  };

  DynamicMode.prototype.updateStickers = function() {
    var _this = this;
    return this.mpd.sendCommand("sticker find song \"/\" \"" + LAST_QUEUED_STICKER + "\"", function(msg) {
      var current_file, line, name, track, value, _i, _len, _ref, _ref2;
      current_file = null;
      _ref = msg.split("\n");
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        line = _ref[_i];
        _ref2 = mpd.split_once(line, ": "), name = _ref2[0], value = _ref2[1];
        if (name === "file") {
          current_file = value;
        } else if (name === "sticker") {
          value = mpd.split_once(value, "=")[1];
          track = _this.mpd.library.track_table[current_file];
          if (track != null) {
            track.last_queued = new Date(value);
          } else {
            _this.log.error("" + current_file + " has a last-queued sticker of " + value + " but we don't have it in our library cache.");
          }
        }
      }
      return _this.got_stickers = true;
    });
  };

  DynamicMode.prototype.getRandomSongFiles = function(count) {
    var files, i, index, max_weight, never_queued, rectangle_area, sometimes_queued, total_size, track, triangle_area, _, _ref,
      _this = this;
    if (count === 0) return [];
    never_queued = [];
    sometimes_queued = [];
    _ref = this.mpd.library.track_table;
    for (_ in _ref) {
      track = _ref[_];
      if (track.last_queued != null) {
        sometimes_queued.push(track);
      } else {
        never_queued.push(track);
      }
    }
    sometimes_queued.sort(function(a, b) {
      return b.last_queued.getTime() - a.last_queued.getTime();
    });
    max_weight = sometimes_queued.length;
    triangle_area = Math.floor(max_weight * max_weight / 2);
    rectangle_area = max_weight * never_queued.length;
    total_size = triangle_area + rectangle_area;
    files = [];
    for (i = 0; 0 <= count ? i < count : i > count; 0 <= count ? i++ : i--) {
      index = Math.random() * total_size;
      if (index < triangle_area) {
        track = sometimes_queued[Math.floor(Math.sqrt(index))];
      } else {
        track = never_queued[Math.floor((index - triangle_area) / max_weight)];
      }
      files.push(track.file);
    }
    return files;
  };

  return DynamicMode;

})(Plugin);
