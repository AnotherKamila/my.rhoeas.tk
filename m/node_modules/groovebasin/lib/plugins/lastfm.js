var LastFm, LastFmNode, Plugin,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = Object.prototype.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

Plugin = require('../plugin').Plugin;

LastFmNode = require('lastfm').LastFmNode;

exports.Plugin = LastFm = (function(_super) {

  __extends(LastFm, _super);

  function LastFm() {
    this.updateNowPlaying = __bind(this.updateNowPlaying, this);
    this.checkScrobble = __bind(this.checkScrobble, this);
    this.checkTrackNumber = __bind(this.checkTrackNumber, this);
    this.queueScrobble = __bind(this.queueScrobble, this);
    this.flushScrobbleQueue = __bind(this.flushScrobbleQueue, this);
    this.onSocketConnection = __bind(this.onSocketConnection, this);
    this.setMpd = __bind(this.setMpd, this);
    this.saveState = __bind(this.saveState, this);
    this.restoreState = __bind(this.restoreState, this);    LastFm.__super__.constructor.apply(this, arguments);
    this.lastfm = new LastFmNode({
      api_key: process.env.npm_package_config_lastfm_api_key,
      secret: process.env.npm_package_config_lastfm_secret
    });
    this.previous_now_playing_id = null;
    this.last_playing_item = null;
    this.playing_start = new Date();
    this.playing_time = 0;
    this.previous_play_state = null;
    setTimeout(this.flushScrobbleQueue, 120000);
  }

  LastFm.prototype.restoreState = function(state) {
    var _ref, _ref2;
    this.scrobblers = (_ref = state.lastfm_scrobblers) != null ? _ref : {};
    return this.scrobbles = (_ref2 = state.scrobbles) != null ? _ref2 : [];
  };

  LastFm.prototype.saveState = function(state) {
    state.lastfm_scrobblers = this.scrobblers;
    state.scrobbles = this.scrobbles;
    return state.status.lastfm_api_key = process.env.npm_package_config_lastfm_api_key;
  };

  LastFm.prototype.setMpd = function(mpd) {
    var _this = this;
    this.mpd = mpd;
    return this.mpd.on('statusupdate', function() {
      _this.updateNowPlaying();
      return _this.checkScrobble();
    });
  };

  LastFm.prototype.onSocketConnection = function(socket) {
    var _this = this;
    socket.on('LastfmGetSession', function(data) {
      _this.log.debug("getting session with " + data);
      return _this.lastfm.request("auth.getSession", {
        token: data.toString(),
        handlers: {
          success: function(data) {
            var _ref;
            delete _this.scrobblers[data != null ? (_ref = data.session) != null ? _ref.name : void 0 : void 0];
            socket.emit('LastfmGetSessionSuccess', JSON.stringify(data));
            return _this.log.debug("success from last.fm auth.getSession: " + (JSON.stringify(data)));
          },
          error: function(error) {
            _this.log.error("error from last.fm auth.getSession: " + error.message);
            return socket.emit('LastfmGetSessionError', JSON.stringify(error));
          }
        }
      });
    });
    socket.on('LastfmScrobblersAdd', function(data) {
      var data_str, params;
      data_str = data.toString();
      _this.log.debug("LastfmScrobblersAdd: " + data_str);
      params = JSON.parse(data_str);
      if (_this.scrobblers[params.username] != null) return;
      _this.scrobblers[params.username] = params.session_key;
      return _this.onStateChanged();
    });
    return socket.on('LastfmScrobblersRemove', function(data) {
      var params, session_key;
      params = JSON.parse(data.toString());
      session_key = _this.scrobblers[params.username];
      if (session_key === params.session_key) {
        delete _this.scrobblers[params.username];
        return _this.onStateChanged();
      } else {
        return _this.log.warn("Invalid session key from user trying to remove scrobbler: " + params.username);
      }
    });
  };

  LastFm.prototype.flushScrobbleQueue = function() {
    var count, max_simultaneous, params,
      _this = this;
    this.log.debug("flushing scrobble queue");
    max_simultaneous = 10;
    count = 0;
    while (((params = this.scrobbles.shift()) != null) && count++ < max_simultaneous) {
      this.log.info("scrobbling " + params.track + " for session " + params.sk);
      params.handlers = {
        error: function(error) {
          _this.log.error("error from last.fm track.scrobble: " + error.message);
          if (!((error != null ? error.code : void 0) != null) || error.code === 11 || error.code === 16) {
            _this.scrobbles.push(params);
            return _this.onStateChanged();
          }
        }
      };
      this.lastfm.request('track.scrobble', params);
    }
    return this.onStateChanged();
  };

  LastFm.prototype.queueScrobble = function(params) {
    this.scrobbles.push(params);
    return this.onStateChanged();
  };

  LastFm.prototype.checkTrackNumber = function(trackNumber) {
    if (parseInt(trackNumber) >= 0) {
      return trackNumber;
    } else {
      return "";
    }
  };

  LastFm.prototype.checkScrobble = function() {
    var half_amt, max_amt, min_amt, session_key, this_item, track, username, _ref, _ref2, _ref3, _ref4;
    this_item = this.mpd.status.current_item;
    if (this.mpd.status.state === 'play') {
      if (this.previous_play_state !== 'play') {
        this.playing_start = new Date(new Date().getTime() - this.playing_time);
        this.previous_play_state = this.mpd.status.state;
      }
    }
    this.playing_time = new Date().getTime() - this.playing_start.getTime();
    this.log.debug("playtime so far: " + this.playing_time);
    if ((this_item != null ? this_item.id : void 0) === ((_ref = this.last_playing_item) != null ? _ref.id : void 0)) {
      return;
    }
    this.log.debug("ids are different");
    if ((track = (_ref2 = this.last_playing_item) != null ? _ref2.track : void 0) != null) {
      min_amt = 15 * 1000;
      max_amt = 4 * 60 * 1000;
      half_amt = track.time / 2 * 1000;
      if (this.playing_time >= min_amt && (this.playing_time >= max_amt || this.playing_time >= half_amt)) {
        if (track.artist_name) {
          _ref3 = this.scrobblers;
          for (username in _ref3) {
            session_key = _ref3[username];
            this.log.debug("queuing scrobble: " + track.name + " for " + username);
            this.queueScrobble({
              sk: session_key,
              timestamp: Math.round(this.playing_start.getTime() / 1000),
              album: ((_ref4 = track.album) != null ? _ref4.name : void 0) || "",
              track: track.name || "",
              artist: track.artist_name || "",
              albumArtist: track.album_artist_name || "",
              duration: track.time || "",
              trackNumber: this.checkTrackNumber(track.track)
            });
          }
          this.flushScrobbleQueue();
        } else {
          this.log.warn("Not scrobbling " + track.name + " - missing artist.");
        }
      }
    }
    this.last_playing_item = this_item;
    this.previous_play_state = this.mpd.status.state;
    this.playing_start = new Date();
    return this.playing_time = 0;
  };

  LastFm.prototype.updateNowPlaying = function() {
    var session_key, track, username, _ref, _ref2, _ref3, _ref4, _results,
      _this = this;
    if (this.mpd.status.state !== 'play') return;
    if ((track = (_ref = this.mpd.status.current_item) != null ? _ref.track : void 0) == null) {
      return;
    }
    if (this.previous_now_playing_id === this.mpd.status.current_item.id) return;
    this.previous_now_playing_id = this.mpd.status.current_item.id;
    if (!track.artist_name) {
      this.log.warn("Not updating last.fm now playing for " + track.name + ": missing artist");
      return;
    }
    _ref2 = this.scrobblers;
    _results = [];
    for (username in _ref2) {
      session_key = _ref2[username];
      this.log.debug("update now playing with session_key: " + session_key + ", track: " + track.name + ", artist: " + track.artist_name + ", album: " + ((_ref3 = track.album) != null ? _ref3.name : void 0));
      _results.push(this.lastfm.request("track.updateNowPlaying", {
        sk: session_key,
        track: track.name || "",
        artist: track.artist_name || "",
        album: ((_ref4 = track.album) != null ? _ref4.name : void 0) || "",
        albumArtist: track.album_artist_name || "",
        trackNumber: this.checkTrackNumber(track.track),
        duration: track.time || "",
        handlers: {
          error: function(error) {
            return _this.log.error("error from last.fm track.updateNowPlaying: " + error.message);
          }
        }
      }));
    }
    return _results;
  };

  return LastFm;

})(Plugin);
