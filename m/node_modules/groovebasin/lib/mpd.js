var DEFAULT_ARTIST, MPD_SENTINEL, Mpd, VARIOUS_ARTISTS, boolToInt, bound, dateToElapsed, elapsedToDate, extend, fromMpdVol, noop, parseMaybeUndefNumber, pickNRandomProps, qEscape, sign, sortableTitle, split_once, startsWith, stripPrefixes, titleCompare, toMpdVol, trackNameFromFile, trim, __trim, __trimLeft, __trimRight, _exports,
  __slice = Array.prototype.slice,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

_exports = typeof exports !== "undefined" && exports !== null ? exports : window;

DEFAULT_ARTIST = "[Unknown Artist]";

VARIOUS_ARTISTS = "Various Artists";

MPD_SENTINEL = /^(OK|ACK|list_OK)(.*)$/m;

__trimLeft = /^\s+/;

__trimRight = /\s+$/;

__trim = String.prototype.trim;

trim = __trim != null ? function(text) {
  if (!(text != null)) {
    return "";
  } else {
    return __trim.call(text);
  }
} : function(text) {
  if (!(text != null)) {
    return "";
  } else {
    return text.toString().replace(__trimLeft, "").replace(__trimRight, "");
  }
};

extend = function() {
  var arg, args, obj, prop, val, _i, _len;
  obj = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
  for (_i = 0, _len = args.length; _i < _len; _i++) {
    arg = args[_i];
    for (prop in arg) {
      val = arg[prop];
      obj[prop] = val;
    }
  }
  return obj;
};

elapsedToDate = function(elapsed) {
  return new Date((new Date()) - elapsed * 1000);
};

dateToElapsed = function(date) {
  return ((new Date()) - date) / 1000;
};

bound = function(min, val, max) {
  if (val < min) {
    return min;
  } else if (val > max) {
    return max;
  } else {
    return val;
  }
};

fromMpdVol = function(vol) {
  vol = parseInt(vol);
  if (vol < 0 || vol > 100) return null;
  return vol / 100;
};

toMpdVol = function(vol) {
  return bound(0, Math.round(parseFloat(vol) * 100), 100);
};

startsWith = function(string, str) {
  return string.substring(0, str.length) === str;
};

stripPrefixes = ['the ', 'a ', 'an '];

sortableTitle = function(title) {
  var prefix, t, _i, _len;
  t = title.toLowerCase();
  for (_i = 0, _len = stripPrefixes.length; _i < _len; _i++) {
    prefix = stripPrefixes[_i];
    if (startsWith(t, prefix)) {
      t = t.substring(prefix.length);
      break;
    }
  }
  return t;
};

titleCompare = function(a, b) {
  var _a, _b;
  _a = sortableTitle(a);
  _b = sortableTitle(b);
  if (_a < _b) {
    return -1;
  } else if (_a > _b) {
    return 1;
  } else {
    if (a < b) {
      return -1;
    } else if (a > b) {
      return 1;
    } else {
      return 0;
    }
  }
};

noop = function() {};

qEscape = function(str) {
  return str.toString().replace(/"/g, '\\"');
};

pickNRandomProps = function(obj, n) {
  var count, i, prop, results;
  if (n === 0) return [];
  results = [];
  count = 0;
  for (prop in obj) {
    count += 1;
    for (i = 0; 0 <= n ? i < n : i > n; 0 <= n ? i++ : i--) {
      if (Math.random() < 1 / count) results[i] = prop;
    }
  }
  return results;
};

sign = function(n) {
  if (n > 0) {
    return 1;
  } else if (n < 0) {
    return -1;
  } else {
    return 0;
  }
};

boolToInt = function(b) {
  if (b) {
    return 1;
  } else {
    return 0;
  }
};

parseMaybeUndefNumber = function(n) {
  n = parseInt(n);
  if (isNaN(n)) n = "";
  return n;
};

_exports.split_once = split_once = function(line, separator) {
  var index;
  index = line.indexOf(separator);
  return [line.substr(0, index), line.substr(index + separator.length)];
};

_exports.trackNameFromFile = trackNameFromFile = function(filename) {
  var dot, filetitle, len;
  filetitle = filename.substr(filename.lastIndexOf('/') + 1);
  len = (dot = filetitle.lastIndexOf('.')) >= 0 ? dot : filetitle.length;
  return filetitle.substr(0, len);
};

_exports.Mpd = Mpd = (function() {
  var albumComparator, artistComparator, getOrCreate, makeComparator, trackComparator;

  Mpd.prototype.on = function(event_name, handler) {
    var _base, _ref;
    return ((_ref = (_base = this.event_handlers)[event_name]) != null ? _ref : _base[event_name] = []).push(handler);
  };

  Mpd.prototype.raiseEvent = function() {
    var args, event_name, handler, handlers_list, _i, _len, _results;
    event_name = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    handlers_list = extend([], this.event_handlers[event_name] || []);
    _results = [];
    for (_i = 0, _len = handlers_list.length; _i < _len; _i++) {
      handler = handlers_list[_i];
      _results.push(handler.apply(null, args));
    }
    return _results;
  };

  Mpd.prototype.handleMessage = function(msg) {
    var handler, _ref;
    handler = this.msgHandlerQueue.shift();
    if ((_ref = this.debugMsgConsole) != null) {
      _ref.log(("get-: " + handler.debug_id + ": ") + JSON.stringify(msg));
    }
    if (msg != null) return handler.cb(msg);
  };

  Mpd.prototype.send = function(msg) {
    var _ref, _ref2, _ref3;
    if ((_ref = this.debugMsgConsole) != null) {
      _ref.log(("send: " + ((_ref2 = (_ref3 = this.msgHandlerQueue[this.msgHandlerQueue.length - 1]) != null ? _ref3.debug_id : void 0) != null ? _ref2 : -1) + ": ") + JSON.stringify(msg));
    }
    return this.rawSend(msg);
  };

  Mpd.prototype.receive = function(data) {
    var code, line, m, msg, str;
    this.buffer += data;
    while (true) {
      m = this.buffer.match(MPD_SENTINEL);
      if (!(m != null)) return;
      msg = this.buffer.substring(0, m.index);
      line = m[0], code = m[1], str = m[2];
      if (code === "ACK") {
        this.raiseEvent('error', str);
        this.handleMessage(null);
      } else if (line.indexOf("OK MPD") === 0) {
        this.raiseEvent('connect');
      } else {
        this.handleMessage(msg);
      }
      this.buffer = this.buffer.substring(msg.length + line.length + 1);
    }
  };

  Mpd.prototype.handleIdleResults = function(msg) {
    var system, _i, _len, _ref, _ref2, _results;
    _ref = trim(msg).split("\n");
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      system = _ref[_i];
      if (system.length > 0) {
        _results.push(((_ref2 = this.updateFuncs[system.substring(9)]) != null ? _ref2 : noop)());
      }
    }
    return _results;
  };

  Mpd.prototype.clearPlaylist = function() {
    this.playlist = {};
    this.playlist.item_list = [];
    return this.playlist.item_table = {};
  };

  Mpd.prototype.anticipatePlayId = function(track_id) {
    var item;
    item = this.playlist.item_table[track_id];
    this.status.current_item = item;
    this.status.state = "play";
    this.status.time = item.track.time;
    this.status.track_start_date = new Date();
    return this.raiseEvent('statusupdate');
  };

  Mpd.prototype.anticipateSkip = function(direction) {
    var next_item;
    next_item = this.playlist.item_list[this.status.current_item.pos + direction];
    if (next_item != null) return this.anticipatePlayId(next_item.id);
  };

  Mpd.prototype.parseMpdTracks = function(msg) {
    var current_track, flush_current_track, key, line, mpd_tracks, value, _i, _len, _ref, _ref2;
    if (msg === "") return [];
    mpd_tracks = [];
    current_track = null;
    flush_current_track = function() {
      if (current_track !== null) mpd_tracks.push(current_track);
      return current_track = {};
    };
    _ref = msg.split("\n");
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      line = _ref[_i];
      _ref2 = split_once(line, ": "), key = _ref2[0], value = _ref2[1];
      if (key === 'directory') continue;
      if (key === 'file') flush_current_track();
      current_track[key] = value;
    }
    flush_current_track();
    return mpd_tracks;
  };

  Mpd.prototype.mpdTracksToTrackObjects = function(mpd_tracks) {
    var artist_name, mpd_track, track, tracks, _i, _len;
    tracks = [];
    for (_i = 0, _len = mpd_tracks.length; _i < _len; _i++) {
      mpd_track = mpd_tracks[_i];
      artist_name = trim(mpd_track.Artist);
      track = {
        file: mpd_track.file,
        name: mpd_track.Title || trackNameFromFile(mpd_track.file),
        artist_name: artist_name,
        artist_disambiguation: "",
        album_artist_name: mpd_track.AlbumArtist || artist_name,
        album_name: trim(mpd_track.Album),
        track: parseMaybeUndefNumber(mpd_track.Track),
        time: parseInt(mpd_track.Time),
        year: parseMaybeUndefNumber(mpd_track.Date)
      };
      track.search_tags = [track.artist_name, track.album_artist_name, track.album_name, track.name, track.file].join("\n").toLowerCase();
      tracks.push(track);
    }
    return tracks;
  };

  getOrCreate = function(key, table, initObjFunc) {
    var result;
    result = table[key];
    if (!(result != null)) {
      result = initObjFunc();
      table[key] = result;
    }
    return result;
  };

  makeComparator = function(order_keys) {
    return function(a, b) {
      var order_key, _i, _len;
      for (_i = 0, _len = order_keys.length; _i < _len; _i++) {
        order_key = order_keys[_i];
        a = a[order_key];
        b = b[order_key];
        if (a < b) return -1;
        if (a > b) return 1;
      }
      return 0;
    };
  };

  trackComparator = makeComparator(["track", "name"]);

  albumComparator = makeComparator(["year", "name"]);

  artistComparator = function(a, b) {
    return titleCompare(a.name, b.name);
  };

  Mpd.prototype.buildArtistAlbumTree = function(tracks, library) {
    var album, album_artist_name, album_artists, album_key, artist, artist_count, artist_table, i, k, track, various_artist, _i, _j, _len, _len2, _len3, _len4, _len5, _ref, _ref2, _ref3, _ref4, _ref5;
    library.track_table = {};
    library.album_table = {};
    for (_i = 0, _len = tracks.length; _i < _len; _i++) {
      track = tracks[_i];
      library.track_table[track.file] = track;
      if (track.album_name === "") {
        album_key = track.album_artist_name + "\n";
      } else {
        album_key = track.album_name + "\n";
      }
      album_key = album_key.toLowerCase();
      album = getOrCreate(album_key, library.album_table, function() {
        return {
          name: track.album_name,
          year: track.year,
          tracks: [],
          key: album_key
        };
      });
      track.album = album;
      album.tracks.push(track);
      if (!(album.year != null)) album.year = album_year;
    }
    artist_table = {};
    _ref = library.album_table;
    for (k in _ref) {
      album = _ref[k];
      album_artists = {};
      album.tracks.sort(trackComparator);
      _ref2 = album.tracks;
      for (i = 0, _len2 = _ref2.length; i < _len2; i++) {
        track = _ref2[i];
        track.pos = i;
        album_artist_name = track.album_artist_name;
        album_artists[album_artist_name.toLowerCase()] = 1;
        album_artists[track.artist_name.toLowerCase()] = 1;
      }
      artist_count = 0;
      for (k in album_artists) {
        artist_count += 1;
      }
      if (artist_count > 1) album_artist_name = VARIOUS_ARTISTS;
      if (album_artist_name === VARIOUS_ARTISTS) {
        _ref3 = album.tracks;
        for (_j = 0, _len3 = _ref3.length; _j < _len3; _j++) {
          track = _ref3[_j];
          track.artist_disambiguation = track.artist_name;
        }
      }
      artist = getOrCreate(album_artist_name.toLowerCase(), artist_table, function() {
        return {
          name: album_artist_name,
          albums: []
        };
      });
      album.artist = artist;
      artist.albums.push(album);
    }
    library.artists = [];
    various_artist = null;
    for (k in artist_table) {
      artist = artist_table[k];
      artist.albums.sort(albumComparator);
      _ref4 = artist.albums;
      for (i = 0, _len4 = _ref4.length; i < _len4; i++) {
        album = _ref4[i];
        album.pos = i;
      }
      if (artist.name === VARIOUS_ARTISTS) {
        various_artist = artist;
      } else {
        library.artists.push(artist);
      }
    }
    library.artists.sort(artistComparator);
    if (various_artist != null) library.artists.splice(0, 0, various_artist);
    _ref5 = library.artists;
    for (i = 0, _len5 = _ref5.length; i < _len5; i++) {
      artist = _ref5[i];
      artist.pos = i;
    }
    return library.artist_table = artist_table;
  };

  Mpd.prototype.sendWithCallback = function(cmd, cb) {
    if (cb == null) cb = noop;
    this.msgHandlerQueue.push({
      debug_id: this.msgCounter++,
      cb: cb
    });
    return this.send(cmd + "\n");
  };

  Mpd.prototype.handleIdleResultsLoop = function(msg) {
    this.handleIdleResults(msg);
    if (this.msgHandlerQueue.length === 0) {
      return this.sendWithCallback("idle", this.handleIdleResultsLoop);
    }
  };

  Mpd.prototype.fixPlaylistPosCache = function() {
    var i, item, _len, _ref, _results;
    _ref = this.playlist.item_list;
    _results = [];
    for (i = 0, _len = _ref.length; i < _len; i++) {
      item = _ref[i];
      _results.push(item.pos = i);
    }
    return _results;
  };

  Mpd.prototype.resetServerState = function() {
    this.buffer = "";
    this.msgHandlerQueue = [];
    this.debugMsgConsole = null;
    this.msgCounter = 0;
    this.idling = false;
    this.haveFileListCache = false;
    this.library = {
      artists: [],
      track_table: {}
    };
    this.search_results = this.library;
    this.last_query = "";
    this.clearPlaylist();
    return this.status = {
      current_item: null
    };
  };

  function Mpd() {
    this.scanFiles = __bind(this.scanFiles, this);
    this.authenticate = __bind(this.authenticate, this);
    this.getFileInfo = __bind(this.getFileInfo, this);
    this.changeStatus = __bind(this.changeStatus, this);
    this.setVolume = __bind(this.setVolume, this);
    this.seek = __bind(this.seek, this);
    this.close = __bind(this.close, this);
    this.removeId = __bind(this.removeId, this);
    this.removeIds = __bind(this.removeIds, this);
    this.shiftIds = __bind(this.shiftIds, this);
    this.moveIds = __bind(this.moveIds, this);
    this.playId = __bind(this.playId, this);
    this.prev = __bind(this.prev, this);
    this.next = __bind(this.next, this);
    this.pause = __bind(this.pause, this);
    this.play = __bind(this.play, this);
    this.stop = __bind(this.stop, this);
    this.shuffle = __bind(this.shuffle, this);
    this.clear = __bind(this.clear, this);
    this.queueFileNext = __bind(this.queueFileNext, this);
    this.queueFilesNext = __bind(this.queueFilesNext, this);
    this.queueFile = __bind(this.queueFile, this);
    this.queueFiles = __bind(this.queueFiles, this);
    this.queueRandomTracks = __bind(this.queueRandomTracks, this);
    this.queueRandomTracksCommands = __bind(this.queueRandomTracksCommands, this);
    this.search = __bind(this.search, this);
    this.updateStatus = __bind(this.updateStatus, this);
    this.updatePlaylist = __bind(this.updatePlaylist, this);
    this.updateLibrary = __bind(this.updateLibrary, this);
    this.sendCommands = __bind(this.sendCommands, this);
    this.sendCommand = __bind(this.sendCommand, this);
    this.handleConnectionStart = __bind(this.handleConnectionStart, this);
    this.getArtistAlbums = __bind(this.getArtistAlbums, this);
    this.artistKey = __bind(this.artistKey, this);
    this.removeListener = __bind(this.removeListener, this);
    this.removeEventListeners = __bind(this.removeEventListeners, this);
    this.resetServerState = __bind(this.resetServerState, this);
    this.fixPlaylistPosCache = __bind(this.fixPlaylistPosCache, this);
    this.handleIdleResultsLoop = __bind(this.handleIdleResultsLoop, this);
    this.sendWithCallback = __bind(this.sendWithCallback, this);
    this.buildArtistAlbumTree = __bind(this.buildArtistAlbumTree, this);
    this.mpdTracksToTrackObjects = __bind(this.mpdTracksToTrackObjects, this);
    this.parseMpdTracks = __bind(this.parseMpdTracks, this);
    this.anticipateSkip = __bind(this.anticipateSkip, this);
    this.anticipatePlayId = __bind(this.anticipatePlayId, this);
    this.clearPlaylist = __bind(this.clearPlaylist, this);
    this.handleIdleResults = __bind(this.handleIdleResults, this);
    this.receive = __bind(this.receive, this);
    this.send = __bind(this.send, this);
    this.handleMessage = __bind(this.handleMessage, this);
    this.raiseEvent = __bind(this.raiseEvent, this);
    this.on = __bind(this.on, this);
    var _this = this;
    this.resetServerState();
    this.event_handlers = {};
    this.updateFuncs = {
      database: function() {
        _this.haveFileListCache = false;
        return _this.updateLibrary();
      },
      update: noop,
      stored_playlist: noop,
      playlist: this.updatePlaylist,
      player: this.updateStatus,
      mixer: this.updateStatus,
      output: noop,
      options: this.updateStatus,
      sticker: function() {
        return _this.raiseEvent('stickerupdate');
      },
      subscription: noop,
      message: noop
    };
  }

  Mpd.prototype.removeEventListeners = function(event_name) {
    return (this.event_handlers[event_name] || []).length = 0;
  };

  Mpd.prototype.removeListener = function(event_name, handler) {
    var h, handlers, i, _len;
    handlers = this.event_handlers[event_name] || [];
    for (i = 0, _len = handlers.length; i < _len; i++) {
      h = handlers[i];
      if (h === handler) {
        handlers.splice(i, 1);
        return;
      }
    }
  };

  Mpd.prototype.artistKey = function(artist_name) {
    if (artist_name === DEFAULT_ARTIST) {
      return "";
    } else {
      return artist_name.toLowerCase();
    }
  };

  Mpd.prototype.getArtistAlbums = function(artist_name) {
    return this.search_results.artist_table[this.artistKey(artist_name)].albums;
  };

  Mpd.prototype.handleConnectionStart = function() {
    this.sendCommand("subscribe Status");
    this.updateLibrary();
    this.updateStatus();
    return this.updatePlaylist();
  };

  Mpd.prototype.sendCommand = function(command, callback) {
    if (callback == null) callback = noop;
    if (this.idling) this.send("noidle\n");
    this.sendWithCallback(command, callback);
    this.sendWithCallback("idle", this.handleIdleResultsLoop);
    return this.idling = true;
  };

  Mpd.prototype.sendCommands = function(command_list, callback) {
    if (callback == null) callback = noop;
    if (command_list.length === 0) return;
    return this.sendCommand("command_list_begin\n" + (command_list.join("\n")) + "\ncommand_list_end", callback);
  };

  Mpd.prototype.updateLibrary = function() {
    var _this = this;
    return this.sendCommand('listallinfo', function(msg) {
      var last_query, tracks;
      tracks = _this.mpdTracksToTrackObjects(_this.parseMpdTracks(msg));
      _this.buildArtistAlbumTree(tracks, _this.library);
      _this.haveFileListCache = true;
      last_query = _this.last_query;
      _this.last_query = "";
      return _this.search(last_query);
    });
  };

  Mpd.prototype.updatePlaylist = function(callback) {
    var _this = this;
    if (callback == null) callback = noop;
    return this.sendCommand("playlistinfo", function(msg) {
      var id, mpd_track, mpd_tracks, obj, _i, _len;
      mpd_tracks = _this.parseMpdTracks(msg);
      _this.clearPlaylist();
      for (_i = 0, _len = mpd_tracks.length; _i < _len; _i++) {
        mpd_track = mpd_tracks[_i];
        id = parseInt(mpd_track.Id);
        obj = {
          id: id,
          track: _this.library.track_table[mpd_track.file],
          pos: _this.playlist.item_list.length
        };
        _this.playlist.item_list.push(obj);
        _this.playlist.item_table[id] = obj;
      }
      if (_this.status.current_item != null) {
        _this.status.current_item = _this.playlist.item_table[_this.status.current_item.id];
      }
      if (_this.status.current_item != null) {
        _this.raiseEvent('playlistupdate');
        return callback();
      } else {
        return _this.updateStatus(function() {
          callback();
          return _this.raiseEvent('playlistupdate');
        });
      }
    });
  };

  Mpd.prototype.updateStatus = function(callback) {
    var _this = this;
    if (callback == null) callback = noop;
    this.sendCommand("status", function(msg) {
      var key, line, o, val, _i, _len, _ref, _ref2;
      o = {};
      _ref = (function() {
        var _j, _len, _ref, _results;
        _ref = msg.split("\n");
        _results = [];
        for (_j = 0, _len = _ref.length; _j < _len; _j++) {
          line = _ref[_j];
          _results.push(split_once(line, ": "));
        }
        return _results;
      })();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        _ref2 = _ref[_i], key = _ref2[0], val = _ref2[1];
        o[key] = val;
      }
      extend(_this.status, {
        volume: fromMpdVol(o.volume),
        repeat: parseInt(o.repeat) !== 0,
        random: parseInt(o.random) !== 0,
        single: parseInt(o.single) !== 0,
        consume: parseInt(o.consume) !== 0,
        state: o.state,
        time: null,
        bitrate: null,
        track_start_date: null
      });
      if (o.bitrate != null) _this.status.bitrate = parseInt(o.bitrate);
      if ((o.time != null) && (o.elapsed != null)) {
        _this.status.time = parseInt(o.time.split(":")[1]);
        _this.status.elapsed = parseFloat(o.elapsed);
        return _this.status.track_start_date = elapsedToDate(_this.status.elapsed);
      }
    });
    return this.sendCommand("currentsong", function(msg) {
      var id, mpd_track, mpd_tracks, pos, _i, _len, _results;
      mpd_tracks = _this.parseMpdTracks(msg);
      if (mpd_tracks.length === 0) {
        _this.status.current_item = null;
        callback();
        _this.raiseEvent('statusupdate');
        return;
      }
      _results = [];
      for (_i = 0, _len = mpd_tracks.length; _i < _len; _i++) {
        mpd_track = mpd_tracks[_i];
        id = parseInt(mpd_track.Id);
        pos = parseInt(mpd_track.Pos);
        _this.status.current_item = _this.playlist.item_table[id];
        if ((_this.status.current_item != null) && _this.status.current_item.pos === pos) {
          _this.status.current_item.track = _this.library.track_table[mpd_track.file];
          _this.raiseEvent('statusupdate');
          _results.push(callback());
        } else {
          _this.status.current_item = {
            id: id,
            pos: pos,
            track: _this.library.track_table[mpd_track.file]
          };
          _results.push(_this.updatePlaylist(function() {
            callback();
            return _this.raiseEvent('statusupdate');
          }));
        }
      }
      return _results;
    });
  };

  Mpd.prototype.search = function(query) {
    var is_match, k, result, track, words, _ref;
    query = trim(query);
    if (query.length === 0) {
      this.search_results = this.library;
      this.raiseEvent('libraryupdate');
      this.last_query = query;
      return;
    }
    words = query.toLowerCase().split(/\s+/);
    query = words.join(" ");
    if (query === this.last_query) return;
    this.last_query = query;
    result = [];
    _ref = this.library.track_table;
    for (k in _ref) {
      track = _ref[k];
      is_match = (function() {
        var word, _i, _len;
        for (_i = 0, _len = words.length; _i < _len; _i++) {
          word = words[_i];
          if (track.search_tags.indexOf(word) === -1) return false;
        }
        return true;
      })();
      if (is_match) result.push(track);
    }
    this.buildArtistAlbumTree(result, this.search_results = {});
    return this.raiseEvent('libraryupdate');
  };

  Mpd.prototype.queueRandomTracksCommands = function(n) {
    var file, _i, _len, _ref, _results;
    if (!this.haveFileListCache) return [];
    _ref = pickNRandomProps(this.library.track_table, n);
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      file = _ref[_i];
      _results.push("addid \"" + (qEscape(file)) + "\"");
    }
    return _results;
  };

  Mpd.prototype.queueRandomTracks = function(n) {
    return this.sendCommands(this.queueRandomTracksCommands(n));
  };

  Mpd.prototype.queueFiles = function(files, pos) {
    var cmds, file, i, items, _ref, _ref2,
      _this = this;
    if (pos == null) pos = this.playlist.item_list.length;
    if (!files.length) return;
    cmds = [];
    for (i = _ref = files.length - 1; _ref <= 0 ? i <= 0 : i >= 0; _ref <= 0 ? i++ : i--) {
      file = files[i];
      cmds.push("addid \"" + (qEscape(file)) + "\" " + pos);
    }
    items = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = files.length; _i < _len; _i++) {
        file = files[_i];
        _results.push({
          id: null,
          pos: null,
          track: this.library.track_table[file]
        });
      }
      return _results;
    }).call(this);
    (_ref2 = this.playlist.item_list).splice.apply(_ref2, [pos, 0].concat(__slice.call(items)));
    this.fixPlaylistPosCache();
    this.sendCommands(cmds, function(msg) {
      var i, index, item_id, line, _len, _ref3, _results;
      _ref3 = msg.split("\n");
      _results = [];
      for (i = 0, _len = _ref3.length; i < _len; i++) {
        line = _ref3[i];
        index = files.length - 1 - i;
        item_id = parseInt(line.substring(4));
        _results.push(items[index] = item_id);
      }
      return _results;
    });
    return this.raiseEvent('playlistupdate');
  };

  Mpd.prototype.queueFile = function(file, pos) {
    return this.queueFiles([file], pos);
  };

  Mpd.prototype.queueFilesNext = function(files) {
    var new_pos, _ref, _ref2;
    new_pos = ((_ref = (_ref2 = this.status.current_item) != null ? _ref2.pos : void 0) != null ? _ref : -1) + 1;
    return this.queueFiles(files, new_pos);
  };

  Mpd.prototype.queueFileNext = function(file) {
    return this.queueFilesNext([file]);
  };

  Mpd.prototype.clear = function() {
    this.sendCommand("clear");
    this.clearPlaylist();
    return this.raiseEvent('playlistupdate');
  };

  Mpd.prototype.shuffle = function() {
    return this.sendCommand("shuffle");
  };

  Mpd.prototype.stop = function() {
    this.sendCommand("stop");
    this.status.state = "stop";
    return this.raiseEvent('statusupdate');
  };

  Mpd.prototype.play = function() {
    this.sendCommand("play");
    if (this.status.state === "pause") {
      this.status.track_start_date = elapsedToDate(this.status.elapsed);
      this.status.state = "play";
      return this.raiseEvent('statusupdate');
    }
  };

  Mpd.prototype.pause = function() {
    this.sendCommand("pause 1");
    if (this.status.state === "play") {
      this.status.elapsed = dateToElapsed(this.status.track_start_date);
      this.status.state = "pause";
      return this.raiseEvent('statusupdate');
    }
  };

  Mpd.prototype.next = function() {
    this.sendCommand("next");
    return this.anticipateSkip(1);
  };

  Mpd.prototype.prev = function() {
    this.sendCommand("previous");
    return this.anticipateSkip(-1);
  };

  Mpd.prototype.playId = function(track_id) {
    track_id = parseInt(track_id);
    this.sendCommand("playid " + (qEscape(track_id)));
    return this.anticipatePlayId(track_id);
  };

  Mpd.prototype.moveIds = function(track_ids, pos) {
    var cmds, id, item, items, real_pos;
    pos = parseInt(pos);
    items = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = track_ids.length; _i < _len; _i++) {
        id = track_ids[_i];
        if ((item = this.playlist.item_table[id]) != null) _results.push(item);
      }
      return _results;
    }).call(this);
    items.sort(function(a, b) {
      return b.pos - a.pos;
    });
    cmds = [];
    while (items.length > 0) {
      if (pos <= items[0].pos) {
        real_pos = pos;
        item = items.shift();
      } else {
        real_pos = pos - 1;
        item = items.pop();
      }
      cmds.push("moveid " + item.id + " " + real_pos);
      this.playlist.item_list.splice(item.pos, 1);
      this.playlist.item_list.splice(real_pos, 0, item);
      this.fixPlaylistPosCache();
    }
    this.sendCommands(cmds);
    return this.raiseEvent('playlistupdate');
  };

  Mpd.prototype.shiftIds = function(track_ids, offset) {
    var id, item, items, new_pos, _i, _j, _len, _len2, _ref;
    offset = parseInt(offset);
    if (offset === 0 || track_ids.length === 0) return;
    items = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = track_ids.length; _i < _len; _i++) {
        id = track_ids[_i];
        if ((item = this.playlist.item_table[id]) != null) _results.push(item);
      }
      return _results;
    }).call(this);
    items.sort(function(a, b) {
      return sign(offset) * (b.pos - a.pos);
    });
    _ref = [items[0], items[items.length - 1]];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      item = _ref[_i];
      new_pos = item.pos + offset;
      if (new_pos < 0 || new_pos >= this.playlist.item_list.length) return;
    }
    this.sendCommands((function() {
      var _j, _len2, _results;
      _results = [];
      for (_j = 0, _len2 = items.length; _j < _len2; _j++) {
        item = items[_j];
        _results.push("moveid " + item.id + " " + (item.pos + offset));
      }
      return _results;
    })());
    for (_j = 0, _len2 = items.length; _j < _len2; _j++) {
      item = items[_j];
      this.playlist.item_list.splice(item.pos, 1);
      this.playlist.item_list.splice(item.pos + offset, 0, item);
      this.fixPlaylistPosCache();
    }
    return this.raiseEvent('playlistupdate');
  };

  Mpd.prototype.removeIds = function(track_ids) {
    var cmds, item, track_id, _i, _len, _ref;
    cmds = [];
    for (_i = 0, _len = track_ids.length; _i < _len; _i++) {
      track_id = track_ids[_i];
      track_id = parseInt(track_id);
      if (((_ref = this.status.current_item) != null ? _ref.id : void 0) === track_id) {
        this.anticipateSkip(1);
        if (this.status.state !== "play") this.status.state = "stop";
      }
      cmds.push("deleteid " + (qEscape(track_id)));
      item = this.playlist.item_table[track_id];
      delete this.playlist.item_table[item.id];
      this.playlist.item_list.splice(item.pos, 1);
      this.fixPlaylistPosCache();
    }
    this.sendCommands(cmds);
    return this.raiseEvent('playlistupdate');
  };

  Mpd.prototype.removeId = function(track_id) {
    return this.removeIds([track_id]);
  };

  Mpd.prototype.close = function() {
    return this.send("close\n");
  };

  Mpd.prototype.seek = function(pos) {
    pos = parseFloat(pos);
    if (pos < 0) pos = 0;
    if (pos > this.status.time) pos = this.status.time;
    this.sendCommand("seekid " + this.status.current_item.id + " " + (Math.round(pos)));
    this.status.track_start_date = elapsedToDate(pos);
    return this.raiseEvent('statusupdate');
  };

  Mpd.prototype.setVolume = function(vol) {
    vol = toMpdVol(vol);
    this.sendCommand("setvol " + vol);
    this.status.volume = fromMpdVol(vol);
    return this.raiseEvent('statusupdate');
  };

  Mpd.prototype.changeStatus = function(status) {
    var cmds;
    cmds = [];
    if (status.consume != null) {
      this.status.consume = status.consume;
      cmds.push("consume " + (boolToInt(status.consume)));
    }
    if (status.random != null) {
      this.status.random = status.random;
      cmds.push("random " + (boolToInt(status.random)));
    }
    if (status.repeat != null) {
      this.status.repeat = status.repeat;
      cmds.push("repeat " + (boolToInt(status.repeat)));
    }
    if (status.single != null) {
      this.status.single = status.single;
      cmds.push("single " + (boolToInt(status.single)));
    }
    this.sendCommands(cmds);
    return this.raiseEvent('statusupdate');
  };

  Mpd.prototype.getFileInfo = function(file, cb) {
    var _this = this;
    if (cb == null) cb = noop;
    return this.sendCommand("lsinfo \"" + (qEscape(file)) + "\"", function(msg) {
      var track;
      track = _this.mpdTracksToTrackObjects(_this.parseMpdTracks(msg))[0];
      return cb(track);
    });
  };

  Mpd.prototype.authenticate = function(password) {
    return this.sendCommand("password \"" + (qEscape(password)) + "\"");
  };

  Mpd.prototype.scanFiles = function(files) {
    var file;
    return this.sendCommands((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = files.length; _i < _len; _i++) {
        file = files[_i];
        _results.push("update \"" + (qEscape(file)) + "\"");
      }
      return _results;
    })());
  };

  return Mpd;

})();
