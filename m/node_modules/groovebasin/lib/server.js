var DirectMpd, accounts, app, arrayToObject, connectBrowserMpd, connectServerMpd, connect_success, createMpdConnection, default_account, enabled, exec, extend, fileServer, fs, http, io, is_dev_mode, log, makeAssetsIfDev, mpd, mpd_conf, my_mpd, my_mpd_socket, name, net, node_static, plugins, restoreState, root_pass, saveAndSend, saveState, sendStatus, socketio, spawn, state, tryReconnect, uid, _i, _len, _ref, _ref2,
  __slice = Array.prototype.slice,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = Object.prototype.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

fs = require('fs');

http = require('http');

net = require('net');

socketio = require('socket.io');

node_static = require('node-static');

mpd = require('./mpd');

extend = require('node.extend');

spawn = require('child_process').spawn;

arrayToObject = function(array) {
  var item, obj, _i, _len;
  obj = {};
  for (_i = 0, _len = array.length; _i < _len; _i++) {
    item = array[_i];
    obj[item] = true;
  }
  return obj;
};

exec = function(cmd, args, cb) {
  var bin;
  if (args == null) args = [];
  if (cb == null) cb = function() {};
  bin = spawn(cmd, args);
  bin.stdout.on('data', function(data) {
    return process.stdout.write(data);
  });
  bin.stderr.on('data', function(data) {
    return process.stderr.write(data);
  });
  return bin.on('exit', cb);
};

is_dev_mode = process.env.npm_package_config_development_mode === 'true';

makeAssetsIfDev = function(cb) {
  if (is_dev_mode) {
    return exec("cake", ["build"], cb);
  } else {
    return cb();
  }
};

fileServer = new node_static.Server("./public");

app = http.createServer(function(request, response) {
  return makeAssetsIfDev(function() {
    if (!plugins.handleRequest(request, response)) {
      return fileServer.serve(request, response);
    }
  });
}).listen(process.env.npm_package_config_port);

io = socketio.listen(app);

io.set('log level', process.env.npm_package_config_log_level);

log = io.log;

log.info("Serving at http://localhost:" + process.env.npm_package_config_port + "/");

try {
  if (uid = process.env.npm_package_config_user_id) process.setuid(uid);
} catch (error) {
  log.error("error setting uid: " + error);
}

log.info("server running as user " + (process.getuid()));

plugins = {
  objects: {
    lastfm: null,
    dynamicmode: null,
    upload: null,
    download: null,
    chat: null,
    stream: null,
    "delete": null
  },
  initialize: function() {
    var Plugin, name, _results;
    _results = [];
    for (name in this.objects) {
      Plugin = require("./plugins/" + name).Plugin;
      _results.push(this.objects[name] = new Plugin(log, saveState, saveAndSend));
    }
    return _results;
  },
  call: function() {
    var args, fn_name, name, plugin, _ref, _results;
    fn_name = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    _ref = this.objects;
    _results = [];
    for (name in _ref) {
      plugin = _ref[name];
      _results.push(plugin[fn_name].apply(plugin, args));
    }
    return _results;
  },
  handleRequest: function(request, response) {
    var name, plugin, _ref;
    _ref = this.objects;
    for (name in _ref) {
      plugin = _ref[name];
      if (plugin.handleRequest(request, response)) return true;
    }
    return false;
  },
  featuresList: function() {
    var name, plugin, _ref, _results;
    _ref = this.objects;
    _results = [];
    for (name in _ref) {
      plugin = _ref[name];
      _results.push([name, plugin.is_enabled]);
    }
    return _results;
  }
};

state = {
  state_version: 2,
  status: {}
};

saveState = function() {
  plugins.call("saveState", state);
  return fs.writeFile(process.env.npm_package_config_state_file, JSON.stringify(state, null, 4), "utf8");
};

restoreState = function() {
  var loaded_state;
  try {
    loaded_state = JSON.parse(fs.readFileSync(process.env.npm_package_config_state_file, "utf8"));
  } catch (_error) {}
  if ((loaded_state != null ? loaded_state.state_version : void 0) === state.state_version) {
    extend(true, state, loaded_state);
  }
  plugins.call("restoreState", state);
  return plugins.call("saveState", state);
};

sendStatus = function() {
  plugins.call("onSendStatus", state.status);
  return io.sockets.emit('Status', JSON.stringify(state.status));
};

saveAndSend = function() {
  saveState();
  return sendStatus();
};

plugins.initialize();

restoreState();

mpd_conf = null;

root_pass = null;

accounts = null;

default_account = null;

(function() {
  var account, accountIsRoot, account_str, all_permissions, data, mpd_conf_path, n, password, perms, rand_pass, _i, _len, _ref, _ref2, _ref3, _ref4;
  mpd_conf_path = process.env.npm_package_config_mpd_conf;
  try {
    data = fs.readFileSync(mpd_conf_path);
  } catch (error) {
    log.warn("Unable to read " + mpd_conf_path + ": " + error + ". Most features disabled.");
    return;
  }
  mpd_conf = require('./mpdconf').parse(data.toString());
  plugins.call("setConf", mpd_conf, mpd_conf_path);
  if (mpd_conf.auto_update !== "yes") {
    log.warn("recommended to turn auto_update on in " + mpd_conf_path);
  }
  if (mpd_conf.gapless_mp3_playback !== "yes") {
    log.warn("recommended to turn gapless_mp3_playback on in " + mpd_conf_path);
  }
  if (mpd_conf.volume_normalization !== "yes") {
    log.warn("recommended to turn volume_normalization on in " + mpd_conf_path);
  }
  if (isNaN(n = parseInt(mpd_conf.max_command_list_size)) || n < 16384) {
    log.warn("recommended to set max_command_list_size to >= 16384 in " + mpd_conf_path);
  }
  all_permissions = "read,add,control,admin";
  accountIsRoot = function(account) {
    var perm, _i, _len, _ref;
    _ref = all_permissions.split(',');
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      perm = _ref[_i];
      if (!account[perm]) return false;
    }
    return true;
  };
  default_account = arrayToObject(((_ref = mpd_conf.default_permissions) != null ? _ref : all_permissions).split(","));
  if (accountIsRoot(default_account)) root_pass = "";
  accounts = {};
  _ref3 = (_ref2 = mpd_conf.password) != null ? _ref2 : [];
  for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
    account_str = _ref3[_i];
    _ref4 = account_str.split("@"), password = _ref4[0], perms = _ref4[1];
    accounts[password] = account = arrayToObject(perms.split(","));
    if (!(root_pass != null) && accountIsRoot(account)) root_pass = password;
  }
  if (default_account.admin) {
    log.warn("Anonymous users have admin permissions. Recommended to remove `admin` from `default_permissions` in " + mpd_conf_path);
  }
  if (!(root_pass != null)) {
    rand_pass = Math.floor(Math.random() * 99999999999);
    log.error("It is required to have at least one password which is granted all the\npermissions. Recommended to add this line in " + mpd_conf_path + ":\n\n  password \"groovebasin-" + rand_pass + "@" + all_permissions + "\"\n");
    return process.exit(1);
  }
})();

plugins.call("saveState", state);

_ref = plugins.featuresList();
for (_i = 0, _len = _ref.length; _i < _len; _i++) {
  _ref2 = _ref[_i], name = _ref2[0], enabled = _ref2[1];
  if (enabled) {
    log.info("" + name + " is enabled.");
  } else {
    log.warn("" + name + " is disabled.");
  }
}

createMpdConnection = function(unix_socket, cb) {
  var host, path, port, _ref3, _ref4, _ref5, _ref6;
  if (unix_socket && ((path = mpd_conf != null ? (_ref3 = mpd_conf.bind_to_address) != null ? _ref3.unix_socket : void 0 : void 0) != null)) {
    return net.connect(path, cb);
  } else {
    port = (_ref4 = mpd_conf != null ? mpd_conf.port : void 0) != null ? _ref4 : 6600;
    host = (_ref5 = mpd_conf != null ? (_ref6 = mpd_conf.bind_to_address) != null ? _ref6.network : void 0 : void 0) != null ? _ref5 : "localhost";
    return net.connect(port, host, cb);
  }
};

connectBrowserMpd = function(socket) {
  var mpd_socket;
  mpd_socket = createMpdConnection(false, function() {
    log.debug("browser to mpd connect");
    try {
      return socket.emit('MpdConnect');
    } catch (_error) {}
  });
  mpd_socket.on('data', function(data) {
    return socket.emit('FromMpd', data.toString());
  });
  mpd_socket.on('end', function() {
    log.debug("browser mpd disconnect");
    try {
      return socket.emit('MpdDisconnect');
    } catch (_error) {}
  });
  mpd_socket.on('error', function() {
    return log.debug("browser no mpd daemon found.");
  });
  socket.removeAllListeners('ToMpd');
  socket.on('ToMpd', function(data) {
    log.debug("[in] " + data);
    try {
      return mpd_socket.write(data);
    } catch (_error) {}
  });
  socket.removeAllListeners('disconnect');
  return socket.on('disconnect', function() {
    return mpd_socket.end();
  });
};

io.sockets.on('connection', function(socket) {
  var permissions;
  connectBrowserMpd(socket);
  permissions = default_account;
  plugins.call("onSocketConnection", socket, function() {
    return permissions;
  });
  socket.emit('Permissions', JSON.stringify(permissions));
  return socket.on('Password', function(data) {
    var pass, ref, success;
    pass = data.toString();
    if (success = (ref = accounts[pass]) != null) permissions = ref;
    socket.emit('Permissions', JSON.stringify(permissions));
    return socket.emit('PasswordResult', JSON.stringify(success));
  });
});

DirectMpd = (function(_super) {

  __extends(DirectMpd, _super);

  function DirectMpd(mpd_socket) {
    this.mpd_socket = mpd_socket;
    this.rawSend = __bind(this.rawSend, this);
    DirectMpd.__super__.constructor.call(this);
    this.mpd_socket.on('data', this.receive);
  }

  DirectMpd.prototype.rawSend = function(data) {
    try {
      return this.mpd_socket.write(data);
    } catch (_error) {}
  };

  return DirectMpd;

})(mpd.Mpd);

my_mpd = null;

my_mpd_socket = null;

connect_success = true;

connectServerMpd = function() {
  my_mpd_socket = createMpdConnection(true, function() {
    log.info("server to mpd connect");
    connect_success = true;
    my_mpd.handleConnectionStart();
//if (root_pass.length > 0) my_mpd.authenticate(root_pass);
    return io.sockets.clients().forEach(connectBrowserMpd);
  });
  my_mpd_socket.on('end', function() {
    log.warn("server mpd disconnect");
    return tryReconnect();
  });
  my_mpd_socket.on('error', function() {
    if (connect_success) {
      connect_success = false;
      log.warn("server no mpd daemon found.");
    }
    return tryReconnect();
  });
  my_mpd = new DirectMpd(my_mpd_socket);
  my_mpd.on('error', function(msg) {
    return log.error(msg);
  });
  return plugins.call("setMpd", my_mpd);
};

tryReconnect = function() {
  return setTimeout(connectServerMpd, 1000);
};

connectServerMpd();
